import javax.lang.model.element.Modifier

void createJavaClass() throws IOException {
    Collections.sort(mAnnotatedPackages)
    TypeSpec.Builder typeBuilder = TypeSpec.classBuilder("ClassMagic")
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addJavadoc('$S\n', 'DO NOT MODIFY; this class is written automatically by the compiler')
            .addMethod(createPrivateConstructor())

    ParameterizedTypeName listOfClasses = getArrayListOfClasses()
    ClassName arrayListClassName = ClassName.get("java.util", "ArrayList")
    MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("getMagic")
            .returns(listOfClasses)
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
            .addJavadoc('$S\n', 'DO NOT MODIFY; this method is written automatically by the compiler')
            .addStatement("\$T result = new \$T<>(${mAnnotatedPackages.size()})", listOfClasses, arrayListClassName)

    mAnnotatedPackages.each {
        int lastDot = it.lastIndexOf('.')
        String clazzName = it.substring(lastDot + 1)
        String found = it.substring(0, lastDot)
        methodBuilder.addStatement('result.add($L.class)', getTypeName(found, clazzName))
    }

    methodBuilder.addStatement("return result")
    typeBuilder.addMethod(methodBuilder.build())

    String packageName = "com.jbirdvegas.groovy.utils"
    // create a java file writer
    JavaFile.Builder builder = JavaFile.builder(packageName + "." + mProjectName, typeBuilder.build())
    // don't import java.lang.* it's redundant
    builder.skipJavaLangImports(true)
    // use four spaces for indent instead of default two spaces
    builder.indent("    ")
    // create the file in memory
    JavaFile javaFile = builder.build()

    File file = getBuildConfigFile(packageName)
    // ensure file structure
    if (!file.getParentFile().exists() && !file.getParentFile().mkdirs()) {
        throw new IOException("Failed to create directory structure for " + file.getAbsolutePath())
    }

    javaFile.writeTo(file)
}

private static ParameterizedTypeName getArrayListOfClasses() {
    return ParameterizedTypeName.get(ClassName.get("java.util", "List"), ClassName.get(Class.class))
}

/**
 * Removes a paramaterization from an annotated class's name (as seen by the annotation processors
 *
 * @param clazzName name of class, possibly with a \<\T> paramaterization
 * @return clazzName that would conform to #getSimpleName()
 */
private ClassName getTypeName(String packageName, String clazzName) {
    return ClassName.get(packageName, clazzName.contains("<") && clazzName.contains(">")
            ? clazzName.substring(0, clazzName.indexOf("<"))
            : clazzName)
}

File getBuildConfigFile(String group) {
    return new File(String.format(OUTPUT_PATH_FORMAT, mProjectPath, group.replaceAll("\\.", "/"), mProjectName))
}

private MethodSpec createPrivateConstructor() {
    return MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build()
}

private String getStringFormatter(Class clazz) {
    //noinspection Duplicates
    //noinspection GroovyFallthrough
    switch (clazz.getSimpleName().toLowerCase()) {
        case "string":
            // causes the formatter used to wrap the value in quotes correctly
        case "date":
            // date objects are serialized to a string
            return '$S'
        case "long":
            return '$LL'
        case "double":
            return '$LD'
        case "float":
            return '$LF'
        default:
            // for the reset use literal
            return '$L'
    }
}