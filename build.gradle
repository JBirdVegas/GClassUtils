buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
        classpath 'com.squareup:javapoet:1.6.1'
    }
}
apply plugin: 'com.jfrog.bintray'

import com.squareup.javapoet.ClassName
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.TypeSpec

import javax.lang.model.element.Modifier

group 'com.jbirdvegas.groovy.utils'
version '1.0'

apply plugin: 'groovy'
apply plugin: "jacoco"
apply plugin: 'maven-publish'
apply plugin: 'idea'

repositories {
    jcenter()
}

idea {
    module {
        downloadJavadoc true
        downloadSources true
        sourceDirs += new File("$project.projectDir/src/main", 'generated-sources')
        generatedSourceDirs += new File("$project.projectDir/src/main", 'generated-sources')
        name = project.name
        jdkName = JavaVersion.VERSION_1_8
    }
}

jacoco {
    toolVersion = "0.7.6.201602180812"
}

test.finalizedBy jacocoTestReport
test.testLogging {
    events "passed", "skipped", "failed", "standardOut"
    showExceptions true
    exceptionFormat "full"
    showCauses true
    showStackTraces true
}

task sourceJar(type: Jar) {
    from sourceSets.main.allJava
}

artifacts {
    archives sourceJar
}

// Create the pom configuration:
def pomConfig = {
    licenses {
        license {
            name "The Apache Software License, Version 2.0"
            url "http://www.apache.org/licenses/LICENSE-2.0.txt"
            distribution "repo"
        }
    }
    developers {
        developer {
            id "JBirdVegas"
            name "Jon Stanford"
            email "jbirdvegas@gmail.com"
        }
    }
}

publishing {
    repositories {
        mavenLocal()
    }
    publications {
        mavenJava(MavenPublication) {
            from components.java

            pom.withXml {
                def root = asNode()
                root.appendNode('description', 'Adds methods to handle common usecases in Groovy')
                root.appendNode('name', project.name)
                root.appendNode('url', 'https://github.com/JBirdVegas/GClassUtils')
                root.children().last() + pomConfig
            }
        }
    }
}

bintray {
    user = System.getenv('BINTRAY_USER_NAME')//'jbirdvegas'//'n00bware'//
    key = System.getenv('BINTRAY_API_KEY')
//    throw new Exception("user: $user, key: $key")
    publications = ['mavenJava']
    publish = true
    override = true
    pkg {
        repo = "release"
        name = "${group}.${project.name}"
        userOrg = 'jbirdvegas'
        publicDownloadNumbers = true
        labels = ['groovy', 'utils']
        licenses = ['Apache-2.0']
        vcsUrl = 'git@github.com:JBirdVegas/GClassUtils.git'
        githubRepo = 'JBirdVegas/GClassUtils'
    }
}

tasks.findByName('publish').finalizedBy tasks.findByName('bintrayUpload')

// clean up any previous generated sources if they exist
def generatedSourcesDir = new File("${rootDir}/src/main/generated-sources")
if (generatedSourcesDir.exists()) {
    generatedSourcesDir.deleteDir()
}

dependencies {
    compileOnly(project(':annotations')) {
        transitive = false
    }
    compile 'org.codehaus.groovy:groovy-all:2.3.11'
    compile group: 'com.google.code.gson', name: 'gson', version: '2.8.0'
    compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.5'
    testCompile group: 'junit', name: 'junit', version: '4.11'
}

def magicFiles = (sourceSets.main.groovy.files as Set<File>).findAll {
    it.text.contains("@ClassMagic")
}

def map = [:] as HashMap<String, String>
magicFiles.each {
    def relative = ((it.absolutePath - project.projectDir.absolutePath) - '/src/main/groovy/') - '.groovy'
    def lastSlash = relative.lastIndexOf('/')
    def group = relative.substring(0, lastSlash).replaceAll('/', '.')
    def name = relative.substring(lastSlash + 1)
    map.put(name, group)
}

createJavaClass(map)

void createJavaClass(Map<String, String> map) throws IOException {
    TypeSpec.Builder typeBuilder = TypeSpec.classBuilder("GClassUtils")
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addJavadoc('$S\n', 'DO NOT MODIFY; this class is written automatically by the compiler')
            .addMethod(createPrivateConstructor())

    def addMagicMethod = MethodSpec.methodBuilder('addMagic')
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
            .returns(void.class)
            .beginControlFlow("for (\$L applier : getMagic())", ClassName.get('com.jbirdvegas.groovy.utils.internal', 'Applier'))
            .addStatement('applier.applyAll()')
            .endControlFlow()
            .build()
    typeBuilder.addMethod(addMagicMethod)

    ParameterizedTypeName listOfClasses = getArrayListOfClasses()
    ClassName arrayListClassName = ClassName.get("java.util", "ArrayList")
    MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("getMagic")
            .returns(listOfClasses)
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
            .addJavadoc('$S\n', 'DO NOT MODIFY; this method is written automatically by the compiler')
            .addStatement("\$T result = new \$T<>(${map.size()})", listOfClasses, arrayListClassName)
    map.each {
        methodBuilder.addStatement('result.add(new $L())', getTypeName(it.value as String, it.key as String))
    }
    methodBuilder.addStatement("return result")
    typeBuilder.addMethod(methodBuilder.build())

    String packageName = "com.jbirdvegas.groovy.utils"
    // create a java file writer
    JavaFile.Builder builder = JavaFile.builder("${packageName}", typeBuilder.build())
    // don't import java.lang.* it's redundant
    builder.skipJavaLangImports(true)
    // use four spaces for indent instead of default two spaces
    builder.indent("    ")
    // create the file in memory
    JavaFile javaFile = builder.build()

    File file = getBuildConfigFile(packageName)
    // ensure file structure
    if (!file.getParentFile().exists() && !file.getParentFile().mkdirs()) {
        throw new IOException("Failed to create directory structure for " + file.getAbsolutePath())
    }

    javaFile.writeTo(file)
}

private static ParameterizedTypeName getArrayListOfClasses() {
    return ParameterizedTypeName.get(ClassName.get("java.util", "List"), ClassName.get('com.jbirdvegas.groovy.utils.internal', 'Applier'))
}

/**
 * Removes a parameterization from an annotated class's name (as seen by the annotation processors
 *
 * @param clazzName name of class, possibly with a \<\T> parameterization
 * @return clazzName that would conform to #getSimpleName()
 */
private static ClassName getTypeName(String packageName, String clazzName) {
    return ClassName.get(packageName, clazzName.contains("<") && clazzName.contains(">")
            ? clazzName.substring(0, clazzName.indexOf("<"))
            : clazzName)
}

private File getBuildConfigFile(String group) {
    return new File(String.format("%s/src/main/generated-sources", project.projectDir.absolutePath))
}

private static MethodSpec createPrivateConstructor() {
    return MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build()
}