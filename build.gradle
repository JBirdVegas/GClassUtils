buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.squareup:javapoet:1.8.0'
        classpath 'com.github.ben-manes:gradle-versions-plugin:0.14.0'
    }
}

import com.squareup.javapoet.ClassName
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.TypeSpec

import javax.lang.model.element.Modifier

group 'com.jbirdvegas.groovy.utils'
version '1.2'

apply plugin: 'groovy'
apply plugin: "jacoco"
apply plugin: 'maven-publish'
apply plugin: 'idea'
apply plugin: 'signing'
apply plugin: 'com.github.ben-manes.versions'

repositories {
    jcenter()
}

idea {
    module {
        downloadJavadoc true
        downloadSources true
        sourceDirs += new File("$project.projectDir/src/main", 'generated-sources')
        generatedSourceDirs += new File("$project.projectDir/src/main", 'generated-sources')
        name = project.name
        jdkName = JavaVersion.VERSION_1_8
    }
}

jacoco {
    toolVersion = "0.7.6.201602180812"
}

test.finalizedBy jacocoTestReport
test {
    def count = 0
    def allGood = true
    afterTest { desc, result ->
        println "Executed test $desc.className #$desc.name with result: $result.resultType"
        if (result.resultType != 'SUCCESS') {
            allGood = false
        }
        count++
    }
    doLast {
        println "Executed $count tests ${allGood ? 'successfully' : ''}"
    }
}

configurations {
    pom
}

ext {
    pomFilePath = "$project.buildDir.absolutePath/generated-pom.xml"
    pomFile = file(pomFilePath)
}

task sourceJar(type: Jar, dependsOn: 'classes') {
    from sourceSets.main.allSource
    classifier = 'sources'
}

task javadocJar(type: Jar, dependsOn: 'javadoc') {
    from javadoc
    classifier = 'javadoc'
}

artifacts {
    archives jar, sourceJar, javadocJar
    if (pomFile.exists()) {
        pom pomFile
    }
}

signing {
    sign configurations.archives
}

task signJars(type: Sign, dependsOn: [jar, javadocJar, sourceJar]) {
    sign configurations.archives
}

// Create the pom configuration:
def pomConfig = {
    licenses {
        license {
            name "The Apache Software License, Version 2.0"
            url "http://www.apache.org/licenses/LICENSE-2.0.txt"
            distribution "repo"
        }
    }
    developers {
        developer {
            id "JBirdVegas"
            name "Jon Stanford"
            email "jbirdvegas@gmail.com"
        }
    }
}

publishing {
    repositories {
        mavenLocal()
        if (project.version.endsWith('-SNAPSHOT')) {
            maven {
                credentials {
                    username ossrhUsername
                    password ossrhPassword
                }
                url 'https://oss.sonatype.org/content/repositories/snapshots/'
            }
        } else {
            maven {
                credentials {
                    username ossrhUsername
                    password ossrhPassword
                }
                url 'https://oss.sonatype.org/service/local/staging/deploy/maven2/'
            }
        }
    }
    publications {
        mavenJava(MavenPublication) {
            from components.java
            artifact("$project.buildDir.absolutePath/libs/$project.name-${project.version}.jar.asc") {
                extension 'jar.asc'
            }
            artifact(javadocJar) {
                classifier "javadoc"
            }
            artifact("$project.buildDir.absolutePath/libs/$project.name-$project.version-javadoc.jar.asc") {
                classifier "javadoc"
                extension 'jar.asc'
            }
            artifact(sourceJar) {
                classifier "sources"
            }
            artifact("$project.buildDir.absolutePath/libs/$project.name-$project.version-sources.jar.asc") {
                classifier "sources"
                extension 'jar.asc'
            }
            pom.withXml {
                addToNode(asNode(), pomConfig)
            }
            if (signing.required) {
                // Sign the pom.xml.
                pom.withXml {
                    writeTo(project.ext.pomFile)
                    def pomAscFile = signing.sign(project.ext.pomFile).signatureFiles[0]
                    artifact(pomAscFile) {
                        classifier = null
                        extension = 'pom.asc'
                    }
                }
            }
        }
    }
}

def addToNode(def root, def pomConfig) {
    def scm = new Node(root, 'scm')
    scm.appendNode('developerConnection', 'scm:git:https://github.com/JBirdVegas/GClassUtils.git')
    scm.appendNode('url', 'https://github.com/JBirdVegas/GClassUtils.git')

    root.appendNode('description', 'Adds methods to handle common usecases in Groovy')
    root.appendNode('name', project.name)
    root.appendNode('url', 'https://github.com/JBirdVegas/GClassUtils')
    root.children().last() + pomConfig
}

model {
    tasks.generatePomFileForMavenJavaPublication {
        destination = file("$buildDir/generated-pom.xml")
    }
}

dependencies {
    compileOnly(project(':annotations')) {
        transitive = false
    }
    compile 'org.codehaus.groovy:groovy-all:2.4.9'
    compile group: 'com.google.code.gson', name: 'gson', version: '2.8.0'
    compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.5'
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

clean {
    doFirst {
        cleanUpPrevious()
    }
}

tasks.create('generateAnnotatedClassList') {
    inputs.dir("$project.projectDir.absolutePath/src/main/groovy").skipWhenEmpty(true)
    def outputPath = getBuildConfigFile().absolutePath
    outputs.dir(outputPath)
    doLast {
        createJavaClass(getAnnotatedClassesMap())
    }
}
configurations {
    codeGen
}
sourceSets {
    main {
        groovy.srcDir getBuildConfigFile()
    }
}

compileGroovy {
    source += sourceSets.main.allSource
    source += getBuildConfigFile()
}

tasks.findByName('compileJava').dependsOn generateAnnotatedClassList

// TODO MOVE ALL THE BELOW TO IT'S OWN CLASS/FILE
void cleanUpPrevious() {
    // clean up any previous generated sources if they exist
    def generatedSourcesDir = new File("${rootDir}/src/main/generated-sources")
    if (generatedSourcesDir.exists()) {
        generatedSourcesDir.deleteDir()
    }

}

Map<String, String> getAnnotatedClassesMap() {
    def magicFiles = (sourceSets.main.groovy.files as Set<File>).findAll {
        it.text.contains("@ClassMagic")
    }

    def map = [:] as HashMap<String, String>
    magicFiles.each {
        def relative = ((it.absolutePath - project.projectDir.absolutePath) - '/src/main/groovy/') - '.groovy'
        def lastSlash = relative.lastIndexOf('/')
        def group = relative.substring(0, lastSlash).replaceAll('/', '.')
        def name = relative.substring(lastSlash + 1)
        map.put(name, group)
    }
    map
}

void createJavaClass(Map<String, String> map) throws IOException {
    TypeSpec.Builder typeBuilder = TypeSpec.classBuilder("GClassUtils")
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addJavadoc('$S\n', 'DO NOT MODIFY; this class is written automatically by the compiler')
            .addMethod(createPrivateConstructor())

    def addMagicMethod = MethodSpec.methodBuilder('addMagic')
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
            .returns(void.class)
            .beginControlFlow("for (\$L applier : getMagic())", ClassName.get('com.jbirdvegas.groovy.utils.internal', 'Applier'))
            .addStatement('applier.applyAll()')
            .endControlFlow()
            .build()
    typeBuilder.addMethod(addMagicMethod)

    ParameterizedTypeName listOfClasses = getArrayListOfClasses()
    ClassName arrayListClassName = ClassName.get("java.util", "ArrayList")
    MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("getMagic")
            .returns(listOfClasses)
            .addModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
            .addJavadoc('$S\n', 'DO NOT MODIFY; this method is written automatically by the compiler')
            .addStatement("\$T result = new \$T<>(${map.size()})", listOfClasses, arrayListClassName)
    map.each {
        methodBuilder.addStatement('result.add(new $L())', getTypeName(it.value as String, it.key as String))
    }
    methodBuilder.addStatement("return result")
    typeBuilder.addMethod(methodBuilder.build())

    String packageName = "com.jbirdvegas.groovy.utils"
    // create a java file writer
    JavaFile.Builder builder = JavaFile.builder("${packageName}", typeBuilder.build())
    // don't import java.lang.* it's redundant
    builder.skipJavaLangImports(true)
    // use four spaces for indent instead of default two spaces
    builder.indent("    ")
    // create the file in memory
    JavaFile javaFile = builder.build()

    File file = getBuildConfigFile()
    // ensure file structure
    if (!file.getParentFile().exists() && !file.getParentFile().mkdirs()) {
        throw new IOException("Failed to create directory structure for " + file.getAbsolutePath())
    }

    javaFile.writeTo(file)
}

private static ParameterizedTypeName getArrayListOfClasses() {
    return ParameterizedTypeName.get(ClassName.get("java.util", "List"), ClassName.get('com.jbirdvegas.groovy.utils.internal', 'Applier'))
}

/**
 * Removes a parameterization from an annotated class's name (as seen by the annotation processors
 *
 * @param clazzName name of class, possibly with a \<\T> parameterization
 * @return clazzName that would conform to #getSimpleName()
 */
private static ClassName getTypeName(String packageName, String clazzName) {
    return ClassName.get(packageName, clazzName.contains("<") && clazzName.contains(">")
            ? clazzName.substring(0, clazzName.indexOf("<"))
            : clazzName)
}

private File getBuildConfigFile() {
    return project.file("$project.buildDir.absolutePath/generated-sources")
}

private static MethodSpec createPrivateConstructor() {
    return MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build()
}